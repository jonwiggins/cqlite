# cqlite

A SQLite-compatible database engine built from scratch in Rust — entirely generated by AI.

This project is a demonstration of modern AI coding tools. Every line of code — the hand-written SQL tokenizer, recursive descent parser, B-tree storage engine, page cache, rollback journal, and query executor — was written by AI (Claude). cqlite exists to showcase what AI-assisted development can accomplish: a functional, file-compatible SQLite implementation built from first principles, without copying from the SQLite source code or using any existing SQL parsing libraries or database engines.

## Progress Report

**21,255 lines of Rust** (19,334 source + 1,921 tests) | **438 tests passing** (358 unit + 77 integration + 3 sqllogictest harness) | **5,434/5,434 sqllogictest cases (100%)**

### Test Results

| Suite | Passed | Total | Rate |
|-------|--------|-------|------|
| Unit tests | 358 | 358 | 100% |
| Integration tests | 77 | 77 | 100% |
| sqllogictest basic.test | 21 | 21 | 100% |
| sqllogictest select1.test | 1,031 | 1,031 | 100% |
| sqllogictest select2.test | 1,031 | 1,031 | 100% |
| sqllogictest select3.test | 3,351 | 3,351 | 100% |
| **Total** | **5,869** | **5,869** | **100%** |

### What's Implemented

#### Storage Layer (Phases 1-3: Complete)
- **SQLite3 file format**: Read/write compatible database files (100-byte header, page structure, magic string)
- **B-tree engine**: Both B-tree (indexes) and B+tree (tables) with page splitting, merging, and overflow pages
- **Pager**: 4096-byte fixed pages, LRU page cache, freelist page recycling
- **Record serialization**: Variable-length encoding, serial type codes, varint encoding
- **Cross-compatibility**: Databases written by cqlite are readable by sqlite3, and vice versa

#### SQL Parser
- Hand-written tokenizer and recursive descent parser (no parser generators)
- **DML**: SELECT, INSERT (VALUES, SELECT, DEFAULT VALUES, multi-row), UPDATE, DELETE
- **DDL**: CREATE TABLE, CREATE INDEX, DROP TABLE, DROP INDEX, ALTER TABLE (RENAME, ADD COLUMN, DROP COLUMN)
- **Transactions**: BEGIN (DEFERRED/IMMEDIATE/EXCLUSIVE), COMMIT, ROLLBACK
- **Advanced syntax**: WITH/WITH RECURSIVE (CTEs), CASE/WHEN, CAST, EXPLAIN, EXPLAIN QUERY PLAN, PRAGMA
- **INSERT OR**: REPLACE, IGNORE, ABORT, FAIL, ROLLBACK conflict resolution
- **Expressions**: Full operator precedence, BETWEEN, IN, LIKE, IS [NOT] NULL, EXISTS, subqueries

#### Query Execution
- **Scans**: Full table scan, index-based equality scan (automatic index selection)
- **Joins**: INNER, LEFT, CROSS with nested loop join
- **Aggregates**: COUNT, SUM, AVG, MIN, MAX with GROUP BY and HAVING
- **Set operations**: UNION, UNION ALL, INTERSECT, EXCEPT
- **Subqueries**: Scalar, IN, EXISTS (including correlated), FROM subqueries
- **CTEs**: Non-recursive and recursive (WITH RECURSIVE) via iterative fixed-point evaluation
- **Ordering & paging**: ORDER BY (ASC/DESC, multiple columns, column numbers, aliases), LIMIT, OFFSET
- **DISTINCT**: Full result deduplication

#### Constraints
- NOT NULL (on INSERT and UPDATE)
- DEFAULT values
- PRIMARY KEY (INTEGER PRIMARY KEY as rowid alias)
- UNIQUE indexes (with NULL exemption per SQL standard)
- CHECK constraints (column-level and table-level, enforced on INSERT and UPDATE)

#### Transactions (Phase 4: Complete)
- Rollback journal with hot journal recovery on open
- BEGIN/COMMIT/ROLLBACK
- Auto-commit mode (each statement is its own transaction)
- ACID guarantees: atomic commits, crash recovery via journal

#### Indexes (Phase 5: Complete)
- CREATE INDEX / CREATE UNIQUE INDEX / DROP INDEX
- Automatic index maintenance on INSERT, UPDATE, DELETE
- Query planner selects best index for equality conditions in WHERE
- EXPLAIN QUERY PLAN reports index vs. table scan

#### Built-in Functions
- **String**: length, upper, lower, substr, trim, ltrim, rtrim, replace, instr, hex, quote, unicode
- **Numeric**: abs, round, random
- **Type**: typeof, zeroblob
- **Null handling**: coalesce, ifnull, nullif
- **Aggregate**: count, sum, avg, min, max, group_concat
- **Formatting**: printf

#### CLI
- Interactive REPL with `cqlite>` prompt
- Dot-commands: `.schema`, `.tables`, `.quit`, `.read`, `.headers on/off`, `.mode`
- File path as CLI argument: `cqlite mydb.db`

### What's Not Yet Implemented

#### SQL Features
- Window functions (ROW_NUMBER, RANK, LAG, LEAD, etc.)
- RIGHT / FULL OUTER / NATURAL joins
- UPSERT (INSERT ... ON CONFLICT ... DO UPDATE)
- AUTOINCREMENT enforcement (parsed but not executed)
- FOREIGN KEY enforcement (parsed but not executed)
- Generated columns
- Date/time functions (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP parsed but not evaluated)

#### Performance & Optimization
- Join reordering / cost-based query planning
- Index range scans (only equality scans currently)
- External merge sort for large ORDER BY
- Table statistics

#### Concurrency & Advanced Storage
- WAL (Write-Ahead Log) mode — only rollback journal
- Concurrent readers
- Cross-process file locking (SHARED/PENDING/RESERVED/EXCLUSIVE states)
- Savepoints

#### Testing Gaps
- Additional sqllogictest suites (select4+, random, index, etc.)
- Crash recovery stress testing
- Fuzz testing of parser

## Setup

```
./scripts/setup.sh
```

This configures git to use the repo's pre-commit hook, which enforces formatting (`cargo fmt`), linting (`cargo clippy`), and tests (`cargo test`) on every commit.

## Building

```
cargo build
```

## Testing

```
cargo test
```

## Architecture

```
src/
├── main.rs          # CLI / REPL entry point
├── lib.rs           # Public API
├── tokenizer.rs     # Hand-written SQL lexer
├── parser.rs        # Recursive descent parser
├── ast.rs           # AST node definitions
├── planner.rs       # Query planner + DDL/DML execution
├── vm.rs            # Query executor (Volcano model)
├── btree.rs         # B-tree / B+tree implementation
├── pager.rs         # Page cache and I/O layer
├── format.rs        # SQLite3 file format constants
├── schema.rs        # sqlite_master schema reader
├── record.rs        # Record serialization
├── varint.rs        # Variable-length integer encoding
├── types.rs         # Value types, affinity, coercion
├── functions.rs     # Built-in scalar functions
├── journal.rs       # Rollback journal
└── error.rs         # Error types
```

## License

MIT
